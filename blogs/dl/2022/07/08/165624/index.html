<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#0078d4"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#0078d4">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hetan697.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"flat"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":true,"nav":null,"activeClass":"utterances"},"stickytabs":true,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInDown"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="这是目标检测学习所做的笔记，使用pytorch实现。东西很乱，而且截至目前还没有整理完，请见谅。 概要 目标检测相关技术演进 SSD算法 YOLO算法">
<meta property="og:type" content="article">
<meta property="og:title" content="目标检测">
<meta property="og:url" content="http://hetan697.github.io/blogs/dl/2022/07/08/165624/index.html">
<meta property="og:site_name" content="Hetan的博客">
<meta property="og:description" content="这是目标检测学习所做的笔记，使用pytorch实现。东西很乱，而且截至目前还没有整理完，请见谅。 概要 目标检测相关技术演进 SSD算法 YOLO算法">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hetan697.github.io/blogs/dl/2022/07/08/165624/output_5_0.svg">
<meta property="og:image" content="http://hetan697.github.io/blogs/dl/2022/07/08/165624/output_15_0.svg">
<meta property="og:image" content="https://zh.d2l.ai/_images/iou.svg">
<meta property="og:image" content="https://img-blog.csdn.net/20180111160539785">
<meta property="og:image" content="https://img-blog.csdn.net/20180111162053588">
<meta property="og:image" content="https://img-blog.csdn.net/20180111165958113">
<meta property="og:image" content="https://img-blog.csdn.net/20180111195724054">
<meta property="og:image" content="https://img-blog.csdn.net/20180111203920946">
<meta property="og:image" content="https://img-blog.csdn.net/20180111213136173">
<meta property="og:image" content="https://img-blog.csdn.net/20180111214333011">
<meta property="og:image" content="https://img-blog.csdn.net/20180112170815478">
<meta property="article:published_time" content="2022-07-08T08:56:24.000Z">
<meta property="article:modified_time" content="2022-07-14T14:43:40.674Z">
<meta property="article:author" content="Hetan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hetan697.github.io/blogs/dl/2022/07/08/165624/output_5_0.svg">


<link rel="canonical" href="http://hetan697.github.io/blogs/dl/2022/07/08/165624/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://hetan697.github.io/blogs/dl/2022/07/08/165624/","path":"blogs/dl/2022/07/08/165624/","title":"目标检测"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>目标检测 | Hetan的博客</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?9d3d45b6aa0aa3c74a095aba4384c50e"></script>




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hetan的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%A6%81"><span class="nav-number">1.</span> <span class="nav-text">概要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#COCO-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%95%B0%E6%8D%AE%E9%9B%86"><span class="nav-number">2.</span> <span class="nav-text">COCO: 目标检测数据集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bounding-Box-%E8%BE%B9%E7%BC%98%E6%A1%86"><span class="nav-number">3.</span> <span class="nav-text">Bounding Box (边缘框)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IoU-Intersection-Over-Union-%E4%BA%A4%E5%B9%B6%E6%AF%94"><span class="nav-number">4.</span> <span class="nav-text">IoU (Intersection Over Union, 交并比)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%9A%E6%A1%86"><span class="nav-number">5.</span> <span class="nav-text">锚框</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E5%9B%BE%E7%89%87%E5%88%86%E7%B1%BB%E5%88%B0%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="nav-number">6.</span> <span class="nav-text">从图片分类到目标检测</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#labels-%E6%A0%87%E7%AD%BE"><span class="nav-number">6.1.</span> <span class="nav-text">labels (标签)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#loss-function-%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-number">6.2.</span> <span class="nav-text">loss function (损失函数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8"><span class="nav-number">6.3.</span> <span class="nav-text">应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sliding-Windows-%E6%BB%91%E5%8A%A8%E7%AA%97%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">Sliding Windows (滑动窗算法)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.</span> <span class="nav-text">算法流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">7.2.</span> <span class="nav-text">算法优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolutional-Implementation-of-Sliding-Windows"><span class="nav-number">7.3.</span> <span class="nav-text">Convolutional Implementation of Sliding Windows</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bounding-Box-Predictions"><span class="nav-number">8.</span> <span class="nav-text">Bounding Box Predictions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Non-max-Suppression-NMS-%E9%9D%9E%E6%9E%81%E5%A4%A7%E5%80%BC%E6%8A%91%E5%88%B6"><span class="nav-number">9.</span> <span class="nav-text">Non-max Suppression (NMS, 非极大值抑制)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Anchor-Box-%E9%94%9A%E6%A1%86"><span class="nav-number">10.</span> <span class="nav-text">Anchor Box (锚框)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#YOLO"><span class="nav-number">11.</span> <span class="nav-text">YOLO</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Hetan</p>
  <div class="site-description" itemprop="description">普普通通研究生</div>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hetan697" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hetan697" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://hetan697.github.io/blogs/dl/2022/07/08/165624/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Hetan">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hetan的博客">
      <meta itemprop="description" content="普普通通研究生">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="目标检测 | Hetan的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          目标检测
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-08 16:56:24" itemprop="dateCreated datePublished" datetime="2022-07-08T16:56:24+08:00">2022-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-14 22:43:40" itemprop="dateModified" datetime="2022-07-14T22:43:40+08:00">2022-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/dl/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>这是目标检测学习所做的笔记，使用<code>pytorch</code>实现。东西很乱，而且截至目前还没有整理完，请见谅。</p>
<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol>
<li>目标检测相关技术演进</li>
<li><code>SSD</code>算法</li>
<li><code>YOLO</code>算法</li>
</ol>
<span id="more"></span>

<h2 id="COCO-目标检测数据集"><a href="#COCO-目标检测数据集" class="headerlink" title="COCO: 目标检测数据集"></a><a target="_blank" rel="noopener" href="https://cocodataset.org/">COCO</a>: 目标检测数据集</h2><ul>
<li>COCO（Common Objects in Context）是目标检测中比较常见的数据集，类似于Imagenet在图片分类中的地位</li>
<li>COCO数据集中有80 个类别 ，330k 张图片 ，1.5M 物体 （每张图片中有多个物体）</li>
</ul>
<h2 id="Bounding-Box-边缘框"><a href="#Bounding-Box-边缘框" class="headerlink" title="Bounding Box (边缘框)"></a>Bounding Box (边缘框)</h2><p>边缘框可以用4个数字定义，下面为两种常用的表示方法：</p>
<ol>
<li>（左上x，左上y，右下x，右下y）</li>
<li>（中心x，中心y，宽，高）</li>
</ol>
<p>使用第一种方法定义一个<code>bounding box</code>：</p>
<p>向下的方向为y轴的正方向。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bbox是边界框的英文缩写</span></span><br><span class="line">dog_bbox, cat_bbox = [<span class="number">60.0</span>, <span class="number">45.0</span>, <span class="number">378.0</span>, <span class="number">516.0</span>], [<span class="number">400.0</span>, <span class="number">112.0</span>, <span class="number">655.0</span>, <span class="number">493.0</span>]</span><br></pre></td></tr></table></figure>

<p>两种形式可以通过如下方式进行转换，输入参数boxes可以是长度为4的张量，也可以是形状为（，4）的二维张量，其中是边界框的数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">box_corner_to_center</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（左上，右下）转换到（中间，宽度，高度）&quot;&quot;&quot;</span></span><br><span class="line">    x1, y1, x2, y2 = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]  <span class="comment"># 把传来的box解成四个元素</span></span><br><span class="line">    cx = (x1 + x2) / <span class="number">2</span>  <span class="comment"># 计算x的中间位置</span></span><br><span class="line">    cy = (y1 + y2) / <span class="number">2</span>  <span class="comment"># 计算y的中间位置</span></span><br><span class="line">    w = x2 - x1  <span class="comment"># 计算宽度</span></span><br><span class="line">    h = y2 - y1  <span class="comment"># 计算高度</span></span><br><span class="line">    <span class="comment"># `torch.stack`: Concatenates a sequence of tensors along a new dimension</span></span><br><span class="line">    boxes = torch.stack((cx, cy, w, h), axis=-<span class="number">1</span>)  <span class="comment"># 重新生成box以返回</span></span><br><span class="line">    <span class="keyword">return</span> boxes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">box_center_to_corner</span>(<span class="params">boxes</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;从（中间，宽度，高度）转换到（左上，右下）&quot;&quot;&quot;</span></span><br><span class="line">    cx, cy, w, h = boxes[:, <span class="number">0</span>], boxes[:, <span class="number">1</span>], boxes[:, <span class="number">2</span>], boxes[:, <span class="number">3</span>]  <span class="comment"># 把传来的box解成四个元素</span></span><br><span class="line">    x1 = cx - <span class="number">0.5</span> * w  <span class="comment"># 计算左上x</span></span><br><span class="line">    y1 = cy - <span class="number">0.5</span> * h  <span class="comment"># 计算左上y</span></span><br><span class="line">    x2 = cx + <span class="number">0.5</span> * w  <span class="comment"># 计算右下x</span></span><br><span class="line">    y2 = cy + <span class="number">0.5</span> * h  <span class="comment"># 计算右下x</span></span><br><span class="line">    <span class="comment"># `torch.stack`: Concatenates a sequence of tensors along a new dimension</span></span><br><span class="line">    boxes = torch.stack((x1, y1, x2, y2), axis=-<span class="number">1</span>)  <span class="comment"># 重新生成box以返回</span></span><br><span class="line">    <span class="keyword">return</span> boxes</span><br></pre></td></tr></table></figure>

<p>我们可以通过转换两次来验证边界框转换函数的正确性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boxes = torch.tensor((dog_bbox, cat_bbox))</span><br><span class="line">box_center_to_corner(box_corner_to_center(boxes)) == boxes</span><br></pre></td></tr></table></figure>

<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">tensor</span><span class="punctuation">(</span><span class="punctuation">[</span><span class="punctuation">[</span><span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">]</span><span class="operator">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="operator">,</span> <span class="built_in">True</span><span class="punctuation">]</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>下面，将边界框在一张图中画出。在这之前，先导入需要加上边框的图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br><span class="line"></span><br><span class="line">d2l.set_figsize()</span><br><span class="line">img = d2l.plt.imread(<span class="string">&#x27;../img/catdog.jpg&#x27;</span>)</span><br><span class="line">d2l.plt.imshow(img)</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/dl/2022/07/08/165624/output_5_0.svg" alt="svg"></p>
<p>定义一个辅助函数<code>bbox_to_rect</code>将边界框表示成<code>matplotlib</code>的边界框格式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bbox_to_rect</span>(<span class="params">bbox, color</span>):</span><br><span class="line">    <span class="comment"># 将边界框(左上x,左上y,右下x,右下y)格式转换成matplotlib格式：</span></span><br><span class="line">    <span class="comment"># ((左上x,左上y),宽,高)</span></span><br><span class="line">    <span class="keyword">return</span> d2l.plt.Rectangle(</span><br><span class="line">        xy=(bbox[<span class="number">0</span>], bbox[<span class="number">1</span>]), width=bbox[<span class="number">2</span>]-bbox[<span class="number">0</span>], height=bbox[<span class="number">3</span>]-bbox[<span class="number">1</span>],</span><br><span class="line">        fill=<span class="literal">False</span>, edgecolor=color, linewidth=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>在图像上添加边界框之后，我们可以看到两个物体的主要轮廓基本上在两个框内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fig = d2l.plt.imshow(img)</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(dog_bbox, <span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line">fig.axes.add_patch(bbox_to_rect(cat_bbox, <span class="string">&#x27;red&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/blogs/dl/2022/07/08/165624/output_15_0.svg" alt="svg"></p>
<h2 id="IoU-Intersection-Over-Union-交并比"><a href="#IoU-Intersection-Over-Union-交并比" class="headerlink" title="IoU (Intersection Over Union, 交并比)"></a>IoU (Intersection Over Union, 交并比)</h2><p>交并比是指两个集合的交集除以两个集合的并集：</p>
<p>$$J(A,B) &#x3D; \frac{|A∩B|}{|A∪B|}$$</p>
<p><img src="https://zh.d2l.ai/_images/iou.svg" alt="../_images/iou.svg"></p>
<ul>
<li>用于衡量锚框和真实边缘框之间的相似度，是两个框之间的交集与两个框的并集的比值</li>
<li>取值范围[0,1]：0表示没有重叠，1表示完全重合（越接近1，两个框的相似度越高）</li>
<li>它是Jacquard指数的特殊情况(给定两个集合，Jacquard指数表示两个集合的交集和两个集合的并集之间的比值)</li>
</ul>
<p>在接下来部分中，我们将使用交并比来衡量锚框和真实边界框之间、以及不同锚框之间的相似度。 给定两个锚框或边界框的列表，以下<code>box_iou</code>函数将在这两个列表中计算它们成对的交并比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">box_iou</span>(<span class="params">boxes1, boxes2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算两个锚框或边界框列表中成对的交并比&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 函数`box_area`计算各个`box`的面积</span></span><br><span class="line">    box_area = <span class="keyword">lambda</span> boxes: ((boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]) *</span><br><span class="line">                              (boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>]))</span><br><span class="line">    <span class="comment"># boxes1,boxes2的形状: (boxes1的数量,4), (boxes2的数量,4),</span></span><br><span class="line">    <span class="comment"># areas1,areas2的形状: (boxes1的数量,) , (boxes2的数量,)</span></span><br><span class="line">    areas1 = box_area(boxes1)</span><br><span class="line">    areas2 = box_area(boxes2)</span><br><span class="line">    <span class="comment"># inter_upperlefts,inter_lowerrights,inters的形状:</span></span><br><span class="line">    <span class="comment"># (boxes1的数量,boxes2的数量,2)</span></span><br><span class="line">    <span class="comment"># 求交集坐标</span></span><br><span class="line">    inter_upperlefts = torch.<span class="built_in">max</span>(boxes1[:, <span class="literal">None</span>, :<span class="number">2</span>], boxes2[:, :<span class="number">2</span>])</span><br><span class="line">    inter_lowerrights = torch.<span class="built_in">min</span>(boxes1[:, <span class="literal">None</span>, <span class="number">2</span>:], boxes2[:, <span class="number">2</span>:])</span><br><span class="line">    inters = (inter_lowerrights - inter_upperlefts).clamp(<span class="built_in">min</span>=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># inter_areasandunion_areas的形状:(boxes1的数量,boxes2的数量)</span></span><br><span class="line">    <span class="comment"># `inter_areas`为交集面积, `union_areas`为并集面积</span></span><br><span class="line">    inter_areas = inters[:, :, <span class="number">0</span>] * inters[:, :, <span class="number">1</span>]</span><br><span class="line">    union_areas = areas1[:, <span class="literal">None</span>] + areas2 - inter_areas</span><br><span class="line">    <span class="keyword">return</span> inter_areas / union_areas</span><br></pre></td></tr></table></figure>

<h2 id="锚框"><a href="#锚框" class="headerlink" title="锚框"></a>锚框</h2><p>h: 输入图片的高度<br>w: 输入图片的宽度<br>s: scale, 锚框的大小（相对于整张图片大小的比例）<br>r: aspect ratio, 锚框的高宽比<br>锚框的宽度和高度分别是$ws\sqrt{r}$和$hs&#x2F;\sqrt{r}$</p>
<ol>
<li>锚框的类别（class，与锚框相关的对象的类别）</li>
<li>锚框的偏移量（offset，真实边缘框相对于锚框的偏移量）标签</li>
</ol>
<h2 id="从图片分类到目标检测"><a href="#从图片分类到目标检测" class="headerlink" title="从图片分类到目标检测"></a>从图片分类到目标检测</h2><h3 id="labels-标签"><a href="#labels-标签" class="headerlink" title="labels (标签)"></a>labels (标签)</h3><p>图片分类中，神经网络输出每个类的概率，经<code>softmax</code>确定预测的<code>one-hot</code>编码，输出为:$ \begin{bmatrix} c_1 &amp; c_2 &amp; … &amp; c_n \end{bmatrix}^T $，其中，$c$为每一类的标号，如对猫狗分类而言$\begin{bmatrix} 1 &amp; 0\end{bmatrix}^T$可以为猫，则$\begin{bmatrix} 0 &amp; 1\end{bmatrix}^T$为狗。对于锚框而言，输出为：</p>
<p>$$<br>\begin{bmatrix}p_c &amp; b_x &amp; b_y &amp; b_h &amp; b_w &amp; c_1 &amp; c_2 &amp; c_3\end{bmatrix}^T<br>$$</p>
<p>其中，$p_c$表示其中是否检测到目标，若其为0则后续标签均可忽略，$b$表示目标的位置，$b\in[0, 1]$。</p>
<h3 id="loss-function-损失函数"><a href="#loss-function-损失函数" class="headerlink" title="loss function (损失函数)"></a>loss function (损失函数)</h3><p>对于损失函数Loss function，若使用平方误差形式，有两种情况：</p>
<ol>
<li>$P_c&#x3D;1$，即$y_1&#x3D;1$：<br>$$<br>(\hat{y},y)&#x3D;(\hat{y}_1−y_1)^2+(\hat{y}_2−y_2)^2+⋯+(\hat{y}_8−y_8)^2<br>$$</li>
<li>$P_c&#x3D;0$，即$y_1&#x3D;0$：<br>$$<br>(\hat{y},y)&#x3D;(\hat{y}_1−y_1)^2<br>$$</li>
</ol>
<p>当然，除了使用平方误差之外，还可以逻辑回归损失函数，类标签$c_1$ $c_2$ $c_3$也可以通过softmax输出。比较而言，平方误差已经能够取得比较好的效果。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>可以使用上述方式对人脸部分特征点坐标进行定位检测（Landmark Detection），并标记出来：</p>
<p><img src="https://img-blog.csdn.net/20180111160539785" alt="这里写图片描述"></p>
<p>也可以检测人体姿势动作：</p>
<p><img src="https://img-blog.csdn.net/20180111162053588" alt="这里写图片描述"></p>
<h2 id="Sliding-Windows-滑动窗算法"><a href="#Sliding-Windows-滑动窗算法" class="headerlink" title="Sliding Windows (滑动窗算法)"></a>Sliding Windows (滑动窗算法)</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>使用滑动窗算法实现<code>Object Detection</code>有以下几步：</p>
<ol>
<li>训练图片分类网络</li>
<li>在测试图片上选择大小适宜的窗口、合适的步进长度，进行从左到右、从上到下的滑动。每个窗口区域都送入之前构建好的CNN模型进行识别判断，若判断有目标，则此窗口即为目标区域；若判断没有目标，则此窗口为非目标区域。<img src="https://img-blog.csdn.net/20180111165958113" alt="这里写图片描述"></li>
</ol>
<h3 id="算法优缺点"><a href="#算法优缺点" class="headerlink" title="算法优缺点"></a>算法优缺点</h3><ul>
<li>优点：原理简单，不需要人为选定目标区域（检测出目标的滑动窗即为目标区域）。</li>
<li>缺点：<ol>
<li>需要人为设定滑动窗的大小和步进长度。滑动窗过小或过大，步进长度过大会降低目标检测正确率。</li>
<li>每次滑动窗区域都要进行网络计算，算法运行时间长。</li>
</ol>
</li>
</ul>
<p>滑动窗算法虽然简单，但是性能不佳、不够灵活。</p>
<h3 id="Convolutional-Implementation-of-Sliding-Windows"><a href="#Convolutional-Implementation-of-Sliding-Windows" class="headerlink" title="Convolutional Implementation of Sliding Windows"></a>Convolutional Implementation of Sliding Windows</h3><p>滑动窗算法可以使用卷积方式实现以提高运行速度、节约重复运算成本。</p>
<p>首先将全连接层转变成为卷积层，如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180111195724054" alt="这里写图片描述"></p>
<p>全连接层转变成卷积层的操作很简单，只需要使用与上层尺寸一致的 filter 进行卷积运算即可。最终得到的输出层维度是 1×1×4，代表 4 类输出值。</p>
<p>单个窗口区域卷积网络结构建立完毕之后，对于待检测图片，即可使用该网络参数和结构进行运算。例如 16×16×3 的图片，步进长度为 2，CNN网络得到的输出层为 2×2×4。其中，2×2 表示共有 4 个窗口结果；28×28×3 的图片，输出层为 8×8×4，共 64 个窗口结果。</p>
<p><img src="https://img-blog.csdn.net/20180111203920946" alt="这里写图片描述"></p>
<p>之前的滑动窗算法需要反复进行正向计算，例如 16×16×3 的图片需进行 4 次，28×28×3 的图片需进行 64 次。而利用卷积操作代替滑动窗算法，则不管原始图片有多大，只需要进行一次正向计算，大大节约了运算成本。窗口步进长度与选择的 Max Pool 大小有关。如果需要步进长度为 4，只需设置Max Pool 为 4×4 即可。</p>
<h2 id="Bounding-Box-Predictions"><a href="#Bounding-Box-Predictions" class="headerlink" title="Bounding Box Predictions"></a>Bounding Box Predictions</h2><p>滑动窗口算法有时会出现滑动窗不能完全涵盖目标的问题，如下图蓝色窗口所示。YOLO（You Only Look Once）算法可以解决这类问题，生成更加准确的目标区域（如上图红色窗口）。</p>
<p><img src="https://img-blog.csdn.net/20180111213136173" alt="这里写图片描述"></p>
<p>YOLO算法首先将原始图片分割成n×n网格，每个网格代表一块区域。为简化说明，下图中将图片分成3×3网格。</p>
<p><img src="https://img-blog.csdn.net/20180111214333011" alt="这里写图片描述"></p>
<p>然后，利用上一节卷积形式实现滑动窗口算法的思想，对该原始图片构建CNN网络，得到的的输出层维度为 3×3×8。其中，3×3 对应 9 个网格，每个网格的输出包含 8 个元素：</p>
<p>$$<br>output&#x3D;\begin{bmatrix}p_c &amp; b_x &amp; b_y &amp; b_h &amp; b_w &amp; c_1 &amp; c_2 &amp; c_3\end{bmatrix}^T<br>$$</p>
<p>如果目标中心坐标($b_x$, $b_y$)不在当前网格内，则当前网格$p_c&#x3D;0$；相反，则当前网格$p_c&#x3D;1$（即只看中心坐标是否在当前网格内）。判断有目标的网格中，$b_x$, $b_y$, $b_h$, $b_w$限定了目标区域。值得注意的是，当前网格左上角坐标设定为(0, 0)，右下角坐标设定为(1, 1)，($b_x$, $b_y$)范围限定在[0,1]之间，但是$b_h$, $b_w$可以大于1。因为目标可能超出该网格，横跨多个区域，如上图所示。目标占几个网格没有关系，目标中心坐标必然在一个网格之内。划分的网格可以更密一些。网格越小，则多个目标的中心坐标被划分到一个网格内的概率就越小。</p>
<h2 id="Non-max-Suppression-NMS-非极大值抑制"><a href="#Non-max-Suppression-NMS-非极大值抑制" class="headerlink" title="Non-max Suppression (NMS, 非极大值抑制)"></a>Non-max Suppression (NMS, 非极大值抑制)</h2><p>对于多个网格都检测出到同一目标的情况，使用NMS算法得出最为准确的网格</p>
<ol>
<li>计算每个网格的$p_c$值，$p_c$值反映了该网格包含目标中心坐标的可信度。</li>
<li>选取$p_c$值最大值对应的网格和区域</li>
<li>计算该区域与所有其它区域的IoU</li>
<li>剔除掉IoU大于阈值（例如0.5）的所有网格及区域。这样就能保证同一目标只有一个网格与之对应，且该网格Pc最大。</li>
<li>返回<code>步骤2</code>。</li>
</ol>
<p>最后，就能使得每个目标都仅由一个网格和区域对应。</p>
<p>以下<code>nms函数</code>按降序对置信度进行排序并返回其索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nms</span>(<span class="params">boxes, scores, iou_threshold</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;对预测边界框的置信度进行排序&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 排序，这样B[0]就是最大的那个值</span></span><br><span class="line">    B = torch.argsort(scores, dim=-<span class="number">1</span>, descending=<span class="literal">True</span>)</span><br><span class="line">    keep = []  <span class="comment"># 保留预测边界框的指标</span></span><br><span class="line">    <span class="comment"># numel: number of elements</span></span><br><span class="line">    <span class="keyword">while</span> B.numel() &gt; <span class="number">0</span>:</span><br><span class="line">        i = B[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 先把最大的给keep住</span></span><br><span class="line">        keep.append(i)</span><br><span class="line">        <span class="keyword">if</span> B.numel() == <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 若某一种类的锚框不止一个时则计算IoU</span></span><br><span class="line">        iou = box_iou(boxes[i, :].reshape(-<span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">                      boxes[B[<span class="number">1</span>:], :].reshape(-<span class="number">1</span>, <span class="number">4</span>)).reshape(-<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># torch.nonzero: 返回一个二维张量，其中每行都是非零值的索引。</span></span><br><span class="line">        <span class="comment"># 保留大于`iou_threshold`的位置</span></span><br><span class="line">        inds = torch.nonzero(iou &lt;= iou_threshold).reshape(-<span class="number">1</span>)</span><br><span class="line">        B = B[inds + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> torch.tensor(keep, device=boxes.device)</span><br></pre></td></tr></table></figure>

<p>定义函数<code>multibox_detection</code>使用<code>nms</code>将非极大值抑制应用于预测边界框：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multibox_detection</span>(<span class="params">cls_probs, offset_preds, anchors, nms_threshold=<span class="number">0.5</span>,</span></span><br><span class="line"><span class="params">                       pos_threshold=<span class="number">0.009999999</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用非极大值抑制来预测边界框&quot;&quot;&quot;</span></span><br><span class="line">    device, batch_size = cls_probs.device, cls_probs.shape[<span class="number">0</span>]</span><br><span class="line">    anchors = anchors.squeeze(<span class="number">0</span>)</span><br><span class="line">    num_classes, num_anchors = cls_probs.shape[<span class="number">1</span>], cls_probs.shape[<span class="number">2</span>]</span><br><span class="line">    out = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_size):</span><br><span class="line">        cls_prob, offset_pred = cls_probs[i], offset_preds[i].reshape(-<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line">        conf, class_id = torch.<span class="built_in">max</span>(cls_prob[<span class="number">1</span>:], <span class="number">0</span>)</span><br><span class="line">        predicted_bb = offset_inverse(anchors, offset_pred)</span><br><span class="line">        keep = nms(predicted_bb, conf, nms_threshold)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找到所有的non_keep索引，并将类设置为背景</span></span><br><span class="line">        all_idx = torch.arange(num_anchors, dtype=torch.long, device=device)</span><br><span class="line">        combined = torch.cat((keep, all_idx))</span><br><span class="line">        uniques, counts = combined.unique(return_counts=<span class="literal">True</span>)</span><br><span class="line">        non_keep = uniques[counts == <span class="number">1</span>]</span><br><span class="line">        all_id_sorted = torch.cat((keep, non_keep))</span><br><span class="line">        class_id[non_keep] = -<span class="number">1</span></span><br><span class="line">        class_id = class_id[all_id_sorted]</span><br><span class="line">        conf, predicted_bb = conf[all_id_sorted], predicted_bb[all_id_sorted]</span><br><span class="line">        <span class="comment"># pos_threshold是一个用于非背景预测的阈值</span></span><br><span class="line">        below_min_idx = (conf &lt; pos_threshold)</span><br><span class="line">        class_id[below_min_idx] = -<span class="number">1</span></span><br><span class="line">        conf[below_min_idx] = <span class="number">1</span> - conf[below_min_idx]</span><br><span class="line">        pred_info = torch.cat((class_id.unsqueeze(<span class="number">1</span>),</span><br><span class="line">                               conf.unsqueeze(<span class="number">1</span>),</span><br><span class="line">                               predicted_bb), dim=<span class="number">1</span>)</span><br><span class="line">        out.append(pred_info)</span><br><span class="line">    <span class="keyword">return</span> torch.stack(out)</span><br></pre></td></tr></table></figure>

<h2 id="Anchor-Box-锚框"><a href="#Anchor-Box-锚框" class="headerlink" title="Anchor Box (锚框)"></a>Anchor Box (锚框)</h2><p>到目前为止，我们介绍的都是一个网格至多只能检测一个目标。那对于多个目标重叠的情况，例如一个人站在一辆车前面，该如何使用YOLO算法进行检测呢？方法是使用不同形状的Anchor Boxes。</p>
<p>如下图所示，同一网格出现了两个目标：人和车。为了同时检测两个目标，我们可以设置两个Anchor Boxes，Anchor box 1 检测人，Anchor box 2 检测车。也就是说，每个网格多加了一层输出。原来的输出维度是 3×3×8，现在是 3×3×2×8（也可以写成 3×3×16 的形式）。这里的2表示有两个Anchor Boxes，用来在一个网格中同时检测多个目标。每个Anchor box都有一个Pc值，若两个Pc值均大于某阈值，则检测到了两个目标。</p>
<p><img src="https://img-blog.csdn.net/20180112170815478" alt="这里写图片描述"></p>
<p>对于有两个锚框的情况，输出的格式如下：<br>$$<br>output&#x3D;\begin{bmatrix}p_c &amp; b_x &amp; b_y &amp; b_h &amp; b_w &amp; c_1 &amp; c_2 &amp; c_3 &amp; p_c &amp; b_x &amp; b_y &amp; b_h &amp; b_w &amp; c_1 &amp; c_2 &amp; c_3\end{bmatrix}^T<br>$$</p>
<p>在使用YOLO算法时，只需对每个 Anchor box 使用非最大值抑制即可。Anchor Boxes形状的选择可以通过人为选取，也可以使用其他机器学习算法，例如k聚类算法对待检测的所有目标进行形状分类，选择主要形状作为Anchor Boxes。</p>
<h2 id="YOLO"><a href="#YOLO" class="headerlink" title="YOLO"></a>YOLO</h2><ol>
<li>For each grid call, get 2 predicted bounding boxes.</li>
<li>Get rid of low probability predictions.</li>
<li>For each class (pedestrian, car, motorcycle) use non-max suppression to generate final predictions.</li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>谢谢支持！ Thanks for your support!</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/donate_wechatpay.png" alt="Hetan 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/donate_alipay.png" alt="Hetan 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Hetan
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://hetan697.github.io/blogs/dl/2022/07/08/165624/" title="目标检测">http://hetan697.github.io/blogs/dl/2022/07/08/165624/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blogs/phone/mi/2022/05/29/234049/" rel="prev" title="谈谈小米10">
                  <i class="fa fa-chevron-left"></i> 谈谈小米10
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blogs/dl/2022/07/11/204251/" rel="next" title="决策树">
                  决策树 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-face-kiss"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hetan</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"hetan697/hetan697.github.io","issue_term":"title","theme":"boxy-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
